import java.io.*;
import java.math.BigDecimal;
import java.text.DecimalFormat;
import java.util.*;
import java.util.Map.Entry;

import ethicalengine.*;
import ethicalengine.Animal.Species;
import ethicalengine.Character;
import ethicalengine.Character.BodyType;
import ethicalengine.Character.Gender;
import ethicalengine.Person.AgeCategory;
import ethicalengine.Person.Profession;

/**
 * Audit class. Automatically generate decisions and make statistics on a series
 * of scenarios.
 * 
 * @author Jianheng Shi. SID: 1087943. Username: jianheng
 */
public class Audit {
	private Scenario[] scenarios = {};
	private boolean[] decisions = {}; // true means passengers alive, false means pedestrian alive
	private String name = "Unspecified";

	public static void main(String[] args) {
		Audit audit = new Audit();

		audit.setAuditType("Test1");
		audit.run(1000);
		audit.printStatistic();
		System.out.println();

		audit.setAuditType("Test1_APPEND");
		audit.run(1000);
		audit.printStatistic();
		System.out.println();

		audit.printToFile("results.log");
	}

	/**
	 * Constructor with no parameter. Used for random scenarios generated by
	 * function run(int runs).
	 */
	public Audit() {
	}

	/**
	 * Constructor. Used for audit given scenarios import by CSV file.
	 * 
	 * @param scenarios Existing scenarios that you want to import.
	 */
	public Audit(Scenario[] scenarios) {
		this.scenarios = scenarios;
	}

	/**
	 * Make decisions on existing scenarios. Add result into this audit.
	 */
	public void run() {
		this.decisions = new boolean[scenarios.length];
		for (int i = 0; i < scenarios.length; i++) {
			if (EthicalEngine.decide(scenarios[i]).name().equals("PASSENGERS")) {
				decisions[i] = true;
			} else if (EthicalEngine.decide(scenarios[i]).name().equals("PEDESTRIANS")) {
				decisions[i] = false;
			}
		}
	}

	/**
	 * Generate N scenarios automatically, then make decision on each of them. Add
	 * the result into this audit.
	 * 
	 * @param runs How many scenarios you want.
	 */
	public void run(int runs) {
		ScenarioGenerator scenarioGenerater = new ScenarioGenerator();
		Scenario[] newScenarios = new Scenario[runs];
		boolean[] newDecisions = new boolean[runs];
		for (int i = 0; i < runs; i++) {
			newScenarios[i] = scenarioGenerater.generate();
			if (EthicalEngine.decide(newScenarios[i]).name().equals("PASSENGERS")) {
				newDecisions[i] = true;
			} else if (EthicalEngine.decide(newScenarios[i]).name().equals("PEDESTRIANS")) {
				newDecisions[i] = false;
			}
		}
		scenarios = concat(scenarios, newScenarios);
		decisions = concat(decisions, newDecisions);
	}

	/**
	 * Used for set audit's type.
	 * 
	 * @param name Name of the type.
	 */
	public void setAuditType(String name) {
		this.name = name;
	}

	/**
	 * Used for get audit's type.
	 */
	public String getAuditType() {
		return name;
	}

	/**
	 * Used for set audit's decision manually.
	 * 
	 * @param decisions Decisions of this audit's scenarios.
	 */
	public void setDecisions(boolean[] decisions) {
		this.decisions = decisions;
	}

	/**
	 * Used for get audit's decisions.
	 */
	public boolean[] getDecisions() {
		return decisions;
	}

	/**
	 * Rewrite soString function for audit. Return a well constructed string shows
	 * all statistics of this audit.
	 * 
	 * @return Formatted string.
	 */
	public String toString() {
		String head = "======================================\n" + "# " + name
				+ " Audit\n======================================\n";
		String runs = "- % SAVED AFTER " + scenarios.length + " RUNS\n";
		Map<String, Double> stats = new HashMap<String, Double>();
		stats = enumStats(AgeCategory.class);
		stats = concatMap(stats, enumStats(Gender.class));
		stats = concatMap(stats, enumStats(BodyType.class));
		HashMap<String, Double> profession = enumStats(Profession.class);
		// profession.remove("unknown");
		stats = concatMap(stats, profession);
		// stats = concatMap(stats, enumStats(Species.class));
		stats = concatMap(stats, speciesStats());
		stats = concatMap(stats, personAniamlStats());
		stats = concatMap(stats, booleanStats("pregnant"));
		stats = concatMap(stats, booleanStats("green"));
		stats = concatMap(stats, booleanStats("red"));
		stats = concatMap(stats, booleanStats("you"));
		stats = concatMap(stats, booleanStats("pet"));
		stats = sortbykey(stats);
		List<Map.Entry<String, Double>> list = sortMap(stats);
		for (int i = list.size() - 1; i >= 0; i--) {
			if (list.get(i).getValue().isNaN()) {
				list.remove(i);
			}
		}
		String survivalRatio = "";
		for (int i = 0; i < list.size(); i++) {
			survivalRatio = survivalRatio + list.get(i).getKey() + ": " + clipDecimal(list.get(i).getValue()) + "\n";
		}
		String tail = "--\n" + "average age: " + clipDecimal(averageAge()) + "\n";
		String output = head + runs + survivalRatio + tail;
		return output;
	}

	/**
	 * Used for print statistics into the console.
	 */
	public void printStatistic() {
		System.out.print(this.toString());
	}

	/**
	 * Used for save this audit's statistics into a human-readable file.
	 * 
	 * @param filepath Absolute path of the saving file.
	 */
	public void printToFile(String filepath) {
		File f = new File(filepath);
		try {
			FileWriter fr = new FileWriter(f, true);
			String data = toString();
			PrintWriter pw = new PrintWriter(fr);
			pw.print(data + "\n");
			pw.flush();
			fr.flush();
			pw.close();
			fr.close();
		} catch (IOException e) {
			if (e instanceof FileNotFoundException) {
				System.out.print("ERROR: could not print results. Target directory does not exist.\n");
				System.exit(0);
			} else {
				e.printStackTrace();
			}
		}
	}

	/**
	 * List all characters in all scenarios into a character array.
	 * 
	 * @return A character array contains all scenarios' characters.
	 */
	public Character[] allCharacters() {
		Character[] allCharacters = {};
		for (int i = 0; i < scenarios.length; i++) {
			allCharacters = concat(allCharacters, scenarios[i].getPassengers());
			allCharacters = concat(allCharacters, scenarios[i].getPedestrians());
		}
		return allCharacters;
	}

	/**
	 * List all survive characters in all scenarios into a character array.
	 * 
	 * @return A character array contains all survived characters in all scenarios.
	 */
	public Character[] allSurviver() {
		Character[] survivers = {};
		for (int i = 0; i < scenarios.length; i++) {
			if (decisions[i]) {
				survivers = concat(survivers, scenarios[i].getPassengers());
			} else {
				survivers = concat(survivers, scenarios[i].getPedestrians());
			}
		}
		return survivers;
	}

	/**
	 * List all dead characters in all scenarios into a character array.
	 * 
	 * @return A character array contains all dead characters in all scenarios.
	 */
	public Character[] allDead() {
		Character[] deads = {};
		for (int i = 0; i < scenarios.length; i++) {
			if (decisions[i]) {
				deads = concat(deads, scenarios[i].getPedestrians());
			} else {
				deads = concat(deads, scenarios[i].getPassengers());
			}
		}
		return deads;
	}

	/**
	 * Statistics of enumeration characteristics, including AgeCategory, Gender,
	 * BodyType, Profession, Species. Output a HashMap with Key: characteristics,
	 * Value: survive percentage value (NaN if no such characteristics in all
	 * scenarios).
	 * 
	 * @param clazz Class of the enumeration.
	 * @return A map of characteristics-survivePercentage sets.
	 */
	public <T extends Enum<?>> HashMap<String, Double> enumStats(Class<T> clazz) {
		Character[] allCharacters = allCharacters();
		Character[] survivers = allSurviver();
		// stats first column is total number of characters with this particular
		// characteristics
		// second column is number of surviver with this particular characteristics
		// order of characteristics are the same with in the Enum class
		int[][] stats = new int[clazz.getEnumConstants().length][2];
		double[] survivePercentage = new double[stats.length];
		HashMap<String, Double> output = new HashMap<String, Double>();
		// initialize stats 2D arrays with zeros.
		for (int i = 0; i < stats.length; i++) {
			Arrays.fill(stats[i], 0);
		}
		// Enum class to array
		T[] category = clazz.getEnumConstants();
		// Count the number of survivors of a given characteristic
		for (int i = 0; i < survivers.length; i++) {
			if (survivers[i] instanceof Person) {
				for (int j = 0; j < category.length; j++) {
					if (clazz.equals(AgeCategory.class)) {
						if (((Person) survivers[i]).getAgeCategory().equals(category[j])) {
							stats[j][1]++;
						}
					} else if (clazz.equals(Gender.class)) {
						if (((Person) survivers[i]).getGender().equals(category[j])) {
							stats[j][1]++;
						}
					} else if (clazz.equals(BodyType.class)) {
						if (((Person) survivers[i]).getBodyType().equals(category[j])) {
							stats[j][1]++;
						}
					} else if (clazz.equals(Profession.class)) {
						if (((Person) survivers[i]).getAgeCategory().equals(AgeCategory.ADULT)) {
							if (((Person) survivers[i]).getProfession().equals(category[j])) {
								stats[j][1]++;
							}
						}
					}
				}
			} else if (survivers[i] instanceof Animal) {
				for (int j = 0; j < category.length; j++) {
					if (clazz.equals(Species.class)) {
						if (((Animal) survivers[i]).getSpecies().equals(category[j].name().toLowerCase())) {
							stats[j][1]++;
						}
					}
				}
			}
		}
		// Count the total number of a given characteristic
		for (int i = 0; i < allCharacters.length; i++) {
			if (allCharacters[i] instanceof Person) {
				for (int j = 0; j < category.length; j++) {
					if (clazz.equals(AgeCategory.class)) {
						if (((Person) allCharacters[i]).getAgeCategory().equals(category[j])) {
							stats[j][0]++;
						}
					} else if (clazz.equals(Gender.class)) {
						if (((Person) allCharacters[i]).getGender().equals(category[j])) {
							stats[j][0]++;
						}
					} else if (clazz.equals(BodyType.class)) {
						if (((Person) allCharacters[i]).getBodyType().equals(category[j])) {
							stats[j][0]++;
						}
					} else if (clazz.equals(Profession.class)) {
						if (((Person) allCharacters[i]).getAgeCategory().equals(AgeCategory.ADULT)) {
							if (((Person) allCharacters[i]).getProfession().equals(category[j])) {
								stats[j][0]++;
							}
						}
					}
				}
			} else if (allCharacters[i] instanceof Animal) {
				for (int j = 0; j < category.length; j++) {
					if (clazz.equals(Species.class)) {
						if (((Animal) allCharacters[i]).getSpecies().equals(category[j].name().toLowerCase())) {
							stats[j][0]++;
						}
					}
				}
			}
		}
		// Calculate survive percentage of given characteristics
		for (int i = 0; i < survivePercentage.length; i++) {
			survivePercentage[i] = (double) stats[i][1] / stats[i][0];
			if (!Double.isNaN(survivePercentage[i])) {
				survivePercentage[i] = ((double) ((int) (survivePercentage[i] * 10.0))) / 10.0;
			}
		}
		for (int i = 0; i < category.length; i++) {
			output.put(category[i].name().toLowerCase(), survivePercentage[i]);
		}
		return output;
	}

	/**
	 * Statistics of Person/Animal as characteristics. HashMap, the first key is
	 * "person" the first value is person's survive percentage, the second key is
	 * "animal", the second element is animal's survive percentage. Output value NaN
	 * if no person or animal in all scenarios.
	 * 
	 * @return A map of characteristics-survivePercentage sets.
	 */
	public HashMap<String, Double> personAniamlStats() {
		Character[] allCharacters = allCharacters();
		Character[] survivers = allSurviver();
		double[] survivePercentage = { 0, 0 }; // first one is person, second one is animal
		HashMap<String, Double> output = new HashMap<String, Double>();
		int personNum = 0;
		int animalNum = 0;
		int personSurviversNum = 0;
		int animalSurviversNum = 0;
		for (int i = 0; i < allCharacters.length; i++) {
			if (allCharacters[i] instanceof Person) {
				personNum++;
			} else {
				animalNum++;
			}
		}
		for (int i = 0; i < survivers.length; i++) {
			if (survivers[i] instanceof Person) {
				personSurviversNum++;
			} else {
				animalSurviversNum++;
			}
		}
		survivePercentage[0] = (double) personSurviversNum / personNum;
		survivePercentage[1] = (double) animalSurviversNum / animalNum;
		for (int i = 0; i < survivePercentage.length; i++) {
			if (!Double.isNaN(survivePercentage[i])) {
				survivePercentage[i] = ((double) ((int) (survivePercentage[i] * 10.0))) / 10.0;
			}
		}
		output.put("person", survivePercentage[0]);
		output.put("animal", survivePercentage[1]);
		return output;
	}

	/**
	 * Statistics of all Species of Animal as characteristics. HashMap, the key is
	 * species, the value is survive percentage of this species. Output value NaN if
	 * no such species.
	 * 
	 * @return A map of Species-survivePercentage sets.
	 */
	public HashMap<String, Double> speciesStats() {
		Character[] allCharacters = allCharacters();
		Character[] survivers = allSurviver();
		double[] survivePercentage = new double[Animal.allSpecies.size()]; // first one is person, second one is animal
		HashMap<String, Double> output = new HashMap<String, Double>();
		for (int i = 0; i < Animal.allSpecies.size(); i++) {
			int totalNum = 0;
			int survival = 0;
			for (int j = 0; j < allCharacters.length; j++) {
				if (allCharacters[j] instanceof Animal) {
					if (((Animal) allCharacters[j]).getSpecies().equals(Animal.allSpecies.get(i))) {
						totalNum++;
					}
				}
			}
			for (int k = 0; k < survivers.length; k++) {
				if (survivers[k] instanceof Animal) {
					if (((Animal) survivers[k]).getSpecies().equals(Animal.allSpecies.get(i))) {
						survival++;
					}
				}
			}
			survivePercentage[i] = (double) survival / totalNum;
			if (!Double.isNaN(survivePercentage[i])) {
				survivePercentage[i] = ((double) ((int) (survivePercentage[i] * 10.0))) / 10.0;
			}
			output.put(Animal.allSpecies.get(i), survivePercentage[i]);
		}
		return output;
	}

	/**
	 * Statistics of other characteristics. Legal inputs: pregnant, green, red, you,
	 * pet. Output NaN if no such characteristics in all scenarios.
	 * 
	 * @param characteristic Which characteristic we concern.
	 * @return A map of characteristics-survivePercentage sets.
	 */
	public HashMap<String, Double> booleanStats(String characteristic) {
		Character[] allCharacters = allCharacters();
		Character[] survivers = allSurviver();
		double survivePercentage = 0;
		int surviveNum = 0;
		int totalNum = 0;
		HashMap<String, Double> output = new HashMap<String, Double>();
		// When calculate survive percentage of pregnant
		if (characteristic.toLowerCase().equals("pregnant")) {
			for (int i = 0; i < allCharacters.length; i++) {
				if (allCharacters[i] instanceof Person) {
					if (((Person) allCharacters[i]).isPregnant()) {
						totalNum++;
					}
				}
			}
			for (int i = 0; i < survivers.length; i++) {
				if (survivers[i] instanceof Person) {
					if (((Person) survivers[i]).isPregnant()) {
						surviveNum++;
					}
				}
			}
			survivePercentage = (double) surviveNum / totalNum;
			if (!Double.isNaN(survivePercentage)) {
				survivePercentage = ((double) ((int) (survivePercentage * 10.0))) / 10.0;
			}
			output.put("pregnant", survivePercentage);
		}
		// When calculate survive percentage of green light
		else if (characteristic.toLowerCase().equals("green")) {
			for (int i = 0; i < scenarios.length; i++) {
				if (scenarios[i].isLegalCrossing()) {
					totalNum += scenarios[i].getPedestrianCount() + scenarios[i].getPassengerCount();
					if (decisions[i]) {
						surviveNum += scenarios[i].getPassengerCount();
					} else {
						surviveNum += scenarios[i].getPedestrianCount();
					}
				}
			}
			survivePercentage = (double) surviveNum / totalNum;
			if (!Double.isNaN(survivePercentage)) {
				survivePercentage = ((double) ((int) (survivePercentage * 10.0))) / 10.0;
			}
			output.put("green", survivePercentage);
		}
		// When calculate survive percentage of red light
		else if (characteristic.toLowerCase().equals("red")) {
			for (int i = 0; i < scenarios.length; i++) {
				if (!scenarios[i].isLegalCrossing()) {
					totalNum += scenarios[i].getPedestrianCount() + scenarios[i].getPassengerCount();
					if (decisions[i]) {
						surviveNum += scenarios[i].getPassengerCount();
					} else {
						surviveNum += scenarios[i].getPedestrianCount();
					}
				}
			}
			survivePercentage = (double) surviveNum / totalNum;
			if (!Double.isNaN(survivePercentage)) {
				survivePercentage = ((double) ((int) (survivePercentage * 10.0))) / 10.0;
			}
			output.put("red", survivePercentage);
		}
		// When calculate survive percentage of you
		else if (characteristic.toLowerCase().equals("you")) {
			for (int i = 0; i < allCharacters.length; i++) {
				if (allCharacters[i] instanceof Person) {
					if (((Person) allCharacters[i]).isYou()) {
						totalNum++;
					}
				}
			}
			for (int i = 0; i < survivers.length; i++) {
				if (survivers[i] instanceof Person) {
					if (((Person) survivers[i]).isYou()) {
						surviveNum++;
					}
				}
			}
			survivePercentage = (double) surviveNum / totalNum;
			if (!Double.isNaN(survivePercentage)) {
				survivePercentage = ((double) ((int) (survivePercentage * 10.0))) / 10.0;
			}
			output.put("you", survivePercentage);
		}
		// When calculate survive percentage of pets
		else if (characteristic.toLowerCase().equals("pet")) {
			for (int i = 0; i < allCharacters.length; i++) {
				if (allCharacters[i] instanceof Animal) {
					if (((Animal) allCharacters[i]).isPet()) {
						totalNum++;
					}
				}
			}
			for (int i = 0; i < survivers.length; i++) {
				if (survivers[i] instanceof Animal) {
					if (((Animal) survivers[i]).isPet()) {
						surviveNum++;
					}
				}
			}
			survivePercentage = (double) surviveNum / totalNum;
			if (!Double.isNaN(survivePercentage)) {
				survivePercentage = ((double) ((int) (survivePercentage * 10.0))) / 10.0;
			}
			output.put("pet", survivePercentage);
		}
		return output;
	}

	/**
	 * Used for combine two arrays.
	 */
	public static <T> T[] concat(T[] first, T[] second) {
		T[] result = Arrays.copyOf(first, first.length + second.length);
		System.arraycopy(second, 0, result, first.length, second.length);
		return result;
	}

	/**
	 * Used for combine two boolean arrays.
	 */
	public static boolean[] concat(boolean[] first, boolean[] second) {
		boolean[] result = Arrays.copyOf(first, first.length + second.length);
		System.arraycopy(second, 0, result, first.length, second.length);
		return result;
	}

	/**
	 * Used for calculate Average age of all characters in all scenarios.
	 * 
	 * @return Average age of all characters.
	 */
	public double averageAge() {
		Character[] allCharacters = allSurviver();
		int totalAge = 0;
		int personNum = 0;
		for (int i = 0; i < allCharacters.length; i++) {
			if (allCharacters[i] instanceof Person) {
				totalAge += ((Person) allCharacters[i]).getAge();
				personNum++;
			}
		}
		return ((double) totalAge / personNum);
	}

	/**
	 * Used for combine two hash maps.
	 */
	public static Map<String, Double> concatMap(Map<String, Double> a, Map<String, Double> b) {
		Map<String, Double> output = new HashMap<String, Double>();
		output.putAll(a);
		output.putAll(b);
		return output;
	}

	/**
	 * Used for sort a map by its values (big to small). Return a List.
	 */
	public static List<Entry<String, Double>> sortMap(Map<String, Double> a) {
		List<Map.Entry<String, Double>> list = new ArrayList<Map.Entry<String, Double>>(a.entrySet());
		list.sort(new Comparator<Map.Entry<String, Double>>() {
			@Override
			public int compare(Map.Entry<String, Double> o1, Map.Entry<String, Double> o2) {
				return o2.getValue().compareTo(o1.getValue());
			}
		});
		return list;
	}
	
	public static Double clipDecimal(Double d) {
		return ((double) ((int) (d * 10.0))) / 10.0;
	}

	// Function to sort map by Key
	public static Map<String, Double> sortbykey(Map<String, Double> map) {
		TreeMap<String, Double> sorted = new TreeMap<>();
		sorted.putAll(map);
		return sorted;
	}

}
